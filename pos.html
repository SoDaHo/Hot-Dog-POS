<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="theme-color" content="#111111" /><link rel="apple-touch-icon" href="/icons/icon-192.png" />
    <title>Hot-Dog Kasse</title>
    <style>
        *{box-sizing:border-box}
        body { font-family: system-ui, sans-serif; background:#f6f6f6; margin:0; padding-top: env(safe-area-inset-top); padding-bottom: env(safe-area-inset-bottom); }
        @supports (padding: constant(safe-area-inset-top)) {
            body { padding-top: constant(safe-area-inset-top); padding-bottom: constant(safe-area-inset-bottom); }
        }
        header { background:#111; color:#fff; padding:10px 16px; display:flex; align-items:center; gap:12px; flex-wrap:wrap }
        header .right{ margin-left:auto; display:flex; align-items:center; gap:8px; flex-wrap:wrap }
        header a{ color:#fff; text-decoration:none; background:#2a2a2a; padding:6px 10px; border-radius:10px }
        header select { background:#2a2a2a; color:#fff; border:1px solid #444; padding:6px 10px; border-radius:10px; cursor:pointer; font-size:14px }
        header select:focus { outline:2px solid #666 }

        .wrap{ max-width:980px; margin:0 auto; padding:16px }

        /* === STANDARD LAYOUT (Default) === */
        .grid { display:grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap:12px; }
        .card{ background:#fff; border-radius:16px; padding:12px; position:relative; box-shadow:0 2px 6px rgba(0,0,0,.07); }
        .item{ min-height:96px; display:flex; flex-direction:column; gap:8px; }
        .item .row{ display:flex; align-items:center; gap:8px }
        .item h3 { margin:0; font-size:18px; flex:1; }
        .price { position:absolute; top:8px; right:8px; background:#f1f1f1; color:#333; border-radius:10px; padding:4px 8px; font-size:12px; font-weight:700; box-shadow:0 1px 3px rgba(0,0,0,.08) }
        .qty { display:flex; gap:8px; align-items:center; justify-content:center; margin:0 auto }
        .qty button { border:none; border-radius:12px; padding:10px 14px; background:#f2f2f2; cursor:pointer; font-size:18px; touch-action:manipulation; -webkit-tap-highlight-color:transparent }
        .qty .val { min-width:34px; text-align:center; font-weight:800 }
        .badge { background:#111; color:#fff; border-radius:999px; min-width:22px; height:22px; display:none; align-items:center; justify-content:center; font-size:12px; font-weight:800; position:absolute; top:-6px; right:-6px; box-shadow:0 2px 6px rgba(0,0,0,.2); padding:0 6px }
        .add-quick{ display:none; border:none; border-radius:12px; padding:6px 10px; background:#111; color:#fff; cursor:pointer; position:absolute; right:8px; bottom:8px }

        /* === FULL WIDTH LAYOUT (1 pro Zeile) === */
        body.layout-full .grid { grid-template-columns: 1fr; gap:16px; }
        body.layout-full .item { min-height:120px; padding:20px 24px; display:flex; flex-direction:row; align-items:center; gap:20px; }
        body.layout-full .item .row { flex:1; }
        body.layout-full .item h3 { font-size:26px; }
        body.layout-full .price { font-size:18px; padding:8px 14px; position:static; background:#f1f1f1; margin-right:20px; }
        body.layout-full .qty { margin:0; }
        body.layout-full .qty button { padding:20px 28px; font-size:32px; font-weight:700; min-width:70px; }
        body.layout-full .qty .val { min-width:60px; font-size:28px; }
        body.layout-full .badge { display:none !important; }
        body.layout-full .add-quick { display:none !important; }

        /* === FULL WIDTH COMPACT (1 pro Zeile, Buttons links/rechts) === */
        body.layout-full-compact .grid { grid-template-columns: 1fr; gap:16px; }
        body.layout-full-compact .item { min-height:100px; padding:20px 24px; display:grid; grid-template-columns: auto 1fr auto; align-items:center; gap:20px; }
        body.layout-full-compact .item .row { display:contents; }
        body.layout-full-compact .item h3 { font-size:24px; text-align:center; margin:0; grid-column:2; grid-row:1; }
        body.layout-full-compact .price { position:absolute; top:8px; left:50%; transform:translateX(-50%); background:#f1f1f1; color:#333; border-radius:10px; padding:5px 10px; font-size:13px; font-weight:700; box-shadow:0 1px 3px rgba(0,0,0,.08); z-index:1; width:max-content; }
        body.layout-full-compact .qty { display:contents; }
        body.layout-full-compact .qty button:nth-child(1) { grid-column:1; grid-row:1; padding:20px 28px; font-size:32px; font-weight:700; min-width:70px; border:none; border-radius:12px; background:#f2f2f2; cursor:pointer; touch-action:manipulation; -webkit-tap-highlight-color:transparent; }
        body.layout-full-compact .qty .val { display:none; }
        body.layout-full-compact .qty button:nth-child(3) { grid-column:3; grid-row:1; padding:20px 28px; font-size:32px; font-weight:700; min-width:70px; border:none; border-radius:12px; background:#f2f2f2; cursor:pointer; touch-action:manipulation; -webkit-tap-highlight-color:transparent; }
        body.layout-full-compact .badge { display:inline-flex !important; top:-6px; right:8px; left:auto; transform:none; }
        body.layout-full-compact .add-quick { display:none !important; }

        /* === IPAD LARGE LAYOUT (2 pro Zeile) === */
        body.layout-ipad .grid { grid-template-columns: repeat(2, 1fr); gap:16px; }
        body.layout-ipad .item { min-height:120px; padding:14px; }
        body.layout-ipad .item .row { margin-bottom:4px; }
        body.layout-ipad .item h3 { font-size:22px; }
        body.layout-ipad .price { font-size:16px; padding:6px 12px; top:10px; right:10px; }
        body.layout-ipad .qty { margin-top:auto; }
        body.layout-ipad .qty button { padding:18px 26px; font-size:28px; font-weight:700; min-width:65px; }
        body.layout-ipad .qty .val { min-width:55px; font-size:26px; }

        /* === TABLET LAYOUT (3 pro Zeile) === */
        body.layout-tablet .grid { grid-template-columns: repeat(3, 1fr); gap:14px; }
        body.layout-tablet .item { min-height:110px; padding:14px; }
        body.layout-tablet .item h3 { font-size:20px; }
        body.layout-tablet .price { font-size:14px; padding:5px 10px; }
        body.layout-tablet .qty button { padding:16px 20px; font-size:24px; font-weight:700; min-width:60px; }
        body.layout-tablet .qty .val { min-width:48px; font-size:22px; }

        .line { display:flex; justify-content:space-between; align-items:center; gap:12px; padding:12px 14px; background:#fff; border-radius:12px; margin-top:12px; margin-bottom:12px; box-shadow:0 2px 8px rgba(0,0,0,.06) }
        .total { font-size:28px; font-weight:800 }
        .small { font-size:12px; color:#666; display:block; margin-bottom:6px }
        .btn { display:inline-block; border:none; border-radius:12px; padding:12px 16px; background:#111; color:#fff; cursor:pointer; touch-action:manipulation; -webkit-tap-highlight-color:transparent }
        .btn:disabled { background:#999; cursor:not-allowed; opacity:0.6 }

        /* Spinner */
        .spinner { display:inline-block; width:16px; height:16px; border:2px solid rgba(255,255,255,.3); border-top-color:#fff; border-radius:50%; animation:spin .6s linear infinite; margin-right:8px }
        @keyframes spin { to { transform:rotate(360deg) } }

        /* Zahlungsbereich */
        .pay{ display:flex; flex-direction:column; gap:10px; margin-top:0 }
        .pm-grid{ display:grid; gap:12px; align-items:stretch; grid-template-columns: repeat(auto-fit, minmax(min(100%, 180px), 1fr)); }
        .pm-grid button{ padding:14px; border-radius:12px; border:2px solid #ddd; background:#fff; cursor:pointer; height:56px; display:flex; align-items:center; justify-content:center; font-weight:600; font-size:16px; width:100%; touch-action:manipulation; -webkit-tap-highlight-color:transparent }
        .pm-grid button.active{ border-color:#111; box-shadow:0 2px 8px rgba(0,0,0,.1) }

        /* Toast - mit Farben */
        #toast { position:fixed; bottom:24px; left:50%; transform:translateX(-50%); background:#111; color:#fff; padding:10px 18px; border-radius:999px; opacity:0; transition:opacity .25s ease; z-index:1000; cursor:pointer }
        #toast.show { opacity:1 }
        #toast.success { background:#2e7d32 }
        #toast.error { background:#c62828 }
        #toast.warning { background:#f57c00 }
        #toast.info { background:#111 }

        /* Timer Button */
        .timer-btn { background:#2a2a2a; border:none; color:#fff; padding:6px 10px; border-radius:10px; cursor:pointer; font-size:18px; display:flex; align-items:center; gap:4px }
        .timer-btn:hover { background:#444 }
        .timer-btn .badge-count { background:#e53935; color:#fff; font-size:11px; padding:2px 6px; border-radius:999px; margin-left:2px }

        /* Timer Modal */
        .modal-overlay { position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,.5); z-index:900; display:none; align-items:center; justify-content:center }
        .modal-overlay.show { display:flex }
        .modal { background:#fff; border-radius:16px; padding:20px; max-width:500px; width:90%; max-height:80vh; overflow-y:auto; box-shadow:0 4px 20px rgba(0,0,0,.2) }
        .modal h2 { margin:0 0 16px; font-size:20px; display:flex; align-items:center; justify-content:space-between }
        .modal h2 button { background:none; border:none; font-size:24px; cursor:pointer; padding:0 }
        .modal-section { margin-bottom:16px; padding-bottom:16px; border-bottom:1px solid #eee }
        .modal-section:last-child { border-bottom:none; margin-bottom:0; padding-bottom:0 }
        .modal-section h3 { margin:0 0 12px; font-size:14px; color:#666; text-transform:uppercase }
        .timer-form { display:flex; flex-direction:column; gap:12px }
        .timer-form label { font-size:14px; color:#333 }
        .timer-form input, .timer-form select { padding:10px; border:1px solid #ddd; border-radius:8px; font-size:16px }
        .timer-form .row { display:flex; gap:12px; align-items:center }
        .timer-form .row > * { flex:1 }
        .timer-form .duration-inputs { display:flex; gap:8px; align-items:center }
        .timer-form .duration-inputs input { width:60px; text-align:center }
        .timer-form .duration-inputs span { color:#666 }
        .timer-presets { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px }
        .timer-presets button { padding:8px 12px; border:1px solid #ddd; border-radius:8px; background:#f5f5f5; cursor:pointer; font-size:14px }
        .timer-presets button:hover { background:#e0e0e0 }
        .timer-form .checkbox-row { display:flex; align-items:center; gap:8px }
        .timer-form .checkbox-row input[type=checkbox] { width:18px; height:18px }
        .saved-timers { display:flex; flex-direction:column; gap:8px }
        .saved-timer { display:flex; align-items:center; gap:12px; padding:12px; background:#f5f5f5; border-radius:10px }
        .saved-timer .info { flex:1 }
        .saved-timer .info .label { font-weight:600 }
        .saved-timer .info .meta { font-size:12px; color:#666 }
        .saved-timer button { padding:8px 12px; border:none; border-radius:8px; cursor:pointer; font-size:14px }
        .saved-timer .start-btn { background:#111; color:#fff }
        .saved-timer .delete-btn { background:#e53935; color:#fff }

        /* Active Timers Display */
        .active-timers { display:none; margin-top:12px }
        .active-timers.has-timers { display:block }
        .active-timers-grid { display:grid; gap:10px }
        .active-timers-grid.cols-1 { grid-template-columns: 1fr }
        .active-timers-grid.cols-2 { grid-template-columns: repeat(2, 1fr) }
        .active-timers-grid.cols-3 { grid-template-columns: repeat(3, 1fr) }
        @media (max-width: 600px) {
            .active-timers-grid.cols-2, .active-timers-grid.cols-3 { grid-template-columns: 1fr }
        }
        .active-timer { background:#fff; border-radius:12px; padding:14px; box-shadow:0 2px 8px rgba(0,0,0,.08); display:flex; align-items:center; gap:12px }
        .active-timer.running { border-left:4px solid #4caf50 }
        .active-timer.paused { border-left:4px solid #ff9800 }
        .active-timer.finished { border-left:4px solid #e53935; animation:pulse 1s infinite }
        @keyframes pulse { 0%,100%{opacity:1} 50%{opacity:.6} }
        .active-timer .timer-info { flex:1; min-width:0 }
        .active-timer .timer-label { font-weight:600; font-size:14px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis }
        .active-timer .timer-display { font-size:28px; font-weight:700; font-variant-numeric:tabular-nums }
        .active-timer .timer-controls { display:flex; gap:8px }
        .active-timer .timer-controls button { width:44px; height:44px; border:none; border-radius:10px; cursor:pointer; font-size:18px; display:flex; align-items:center; justify-content:center; -webkit-tap-highlight-color:transparent; touch-action:manipulation }
        .active-timer .play-pause { background:#111; color:#fff }
        .active-timer .reset-btn { background:#f5f5f5 }
        .active-timer .stop-btn { background:#e53935; color:#fff }

        /* Mobile kompakt */
        @media (max-width: 600px){
            .grid{ grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)) !important; }
            .item.compact .price{ display:none }
            .item.compact .qty{ display:none }
            .item.compact .badge{ display:inline-flex }
            .item.compact .add-quick{ display:block }
            .item.expanded .qty{ display:flex }
            .item.expanded .price{ display:block; font-size:13px; color:#777 }
            .item.expanded .add-quick{ display:none }

            .pm-grid{ grid-template-columns: repeat(auto-fit, minmax(min(100%, 150px), 1fr)) !important; }
        }
        .item.compact .price{ display:none }
        .item.compact .qty{ display:none }
        .item.compact .badge{ display:inline-flex }
        .item.compact .add-quick{ display:block }
        .item.expanded .qty{ display:flex }
        .item.expanded .price{ display:block; font-size:13px; color:#777 }
        .item.expanded .add-quick{ display:none }
    </style>
</head>
<body>
<header>
    <div>Hot-Dog Kasse</div>
    <select id="layoutSelector" aria-label="Layout ausw√§hlen">
        <option value="standard">Standard</option>
        <option value="full">1 pro Zeile</option>
        <option value="full-compact">1 pro Zeile (Kompakt)</option>
        <option value="ipad">2 pro Zeile (iPad)</option>
        <option value="tablet">3 pro Zeile (Tablet)</option>
    </select>
    <div class="right">
        <button class="timer-btn" onclick="openTimerModal()" title="Timer">
            <span>&#9201;</span>
            <span class="badge-count" id="timerBadge" style="display:none">0</span>
        </button>
        <div>eingeloggt: <strong>{{ user.username }}</strong></div>
        {% if user.is_admin %}<a href="/admin">Admin</a>{% endif %}
        <a href="/logout">Logout</a>
    </div>
</header>

<div class="wrap">
    <div class="grid" id="items"></div>

    <div class="line">
        <div>
            <div class="small">Warenkorb-Summe</div>
            <div class="total"><span id="sum">0.00</span> {{currency}}</div>
        </div>
        <div style="display:flex;gap:8px;align-items:center">
            <button id="clear" class="btn" style="background:#444">Leeren</button>
        </div>
    </div>

    <div class="card pay">
        <div>
            <div class="small">Zahlart</div>
            <div class="pm-grid" id="pm"></div>
        </div>

        <div>
            <button id="pay" class="btn" style="font-size:20px;width:100%">Kassieren</button>
        </div>
    </div>

    <!-- Aktive Timer Anzeige -->
    <div class="active-timers" id="activeTimers">
        <div class="active-timers-grid" id="activeTimersGrid"></div>
    </div>
</div>

<div id="toast"></div>

<!-- Timer Modal -->
<div class="modal-overlay" id="timerModal" onclick="if(event.target===this)closeTimerModal()">
    <div class="modal">
        <h2>
            <span>Timer & Stoppuhren</span>
            <button onclick="closeTimerModal()">&times;</button>
        </h2>

        <!-- Neuen Timer erstellen -->
        <div class="modal-section">
            <h3>Neuen Timer erstellen</h3>
            <div class="timer-form">
                <div class="row">
                    <div>
                        <label>Name</label>
                        <input type="text" id="newTimerLabel" placeholder="z.B. Pommes">
                    </div>
                    <div>
                        <label>Typ</label>
                        <select id="newTimerType" onchange="toggleDurationInputs()">
                            <option value="timer">Timer (Countdown)</option>
                            <option value="stopwatch">Stoppuhr</option>
                        </select>
                    </div>
                </div>
                <div id="durationRow">
                    <label>Dauer</label>
                    <div class="duration-inputs">
                        <input type="number" id="newTimerMin" value="5" min="0" max="99">
                        <span>Min</span>
                        <input type="number" id="newTimerSec" value="0" min="0" max="59">
                        <span>Sek</span>
                    </div>
                    <div class="timer-presets">
                        <button type="button" onclick="setDuration(3,0)">3 Min</button>
                        <button type="button" onclick="setDuration(5,0)">5 Min</button>
                        <button type="button" onclick="setDuration(8,0)">8 Min</button>
                        <button type="button" onclick="setDuration(10,0)">10 Min</button>
                    </div>
                </div>
                <div class="row">
                    <div class="checkbox-row">
                        <input type="checkbox" id="newTimerSound" checked onchange="toggleSoundSelect()">
                        <label for="newTimerSound">Sound bei Ablauf</label>
                    </div>
                    <div id="soundSelectRow">
                        <label>Sound</label>
                        <select id="newTimerSoundType">
                            <option value="beep">Beep</option>
                            <option value="jingle_bells">Jingle Bells</option>
                            <option value="christmas_bells">Weihnachtsglocken</option>
                            <option value="ho_ho_ho">Ho Ho Ho</option>
                            <option value="sleigh_ride">Sleigh Ride</option>
                        </select>
                        <button type="button" class="btn" style="padding:6px 10px;font-size:12px;background:#666;margin-left:4px" onclick="previewSound()">Test</button>
                    </div>
                </div>
                <div class="row">
                    <button class="btn" onclick="createAndStartTimer()">Erstellen & Starten</button>
                    <button class="btn" style="background:#666" onclick="saveTimerPreset()">Nur Speichern</button>
                </div>
            </div>
        </div>

        <!-- Gespeicherte Timer -->
        <div class="modal-section" id="savedTimersSection" style="display:none">
            <h3>Gespeicherte Timer</h3>
            <div class="saved-timers" id="savedTimersList"></div>
        </div>
    </div>
</div>

<script>
    // PWA r√ºckg√§ngig machen: vorhandene Service Worker entfernen & Cache leeren
    if ('serviceWorker' in navigator) {
        navigator.serviceWorker.getRegistrations().then((regs)=>regs.forEach(r=>r.unregister()));
    }
    if (window.caches && caches.keys) {
        caches.keys().then(keys => keys.forEach(k => caches.delete(k)));
    }

    // === Layout Switcher ===
    const layoutSelector = document.getElementById('layoutSelector');
    function applyLayout(layout) {
        document.body.className = ''; // Reset
        if (layout === 'full') {
            document.body.classList.add('layout-full');
        } else if (layout === 'full-compact') {
            document.body.classList.add('layout-full-compact');
        } else if (layout === 'ipad') {
            document.body.classList.add('layout-ipad');
        } else if (layout === 'tablet') {
            document.body.classList.add('layout-tablet');
        }
        // 'standard' hat keine extra Klasse
        localStorage.setItem('posLayout', layout);
    }

    // Load saved layout
    const savedLayout = localStorage.getItem('posLayout') || 'standard';
    layoutSelector.value = savedLayout;
    applyLayout(savedLayout);

    layoutSelector.addEventListener('change', (e) => {
        applyLayout(e.target.value);
    });

    // ==== Kassen-App Logik ====
    const CURRENCY = "{{currency}}";
    const items = {{ items | tojson }};
    const payMethods = {{ pay_methods | tojson | default('[]') }};

    const cart = {};
    let activePM = payMethods.length ? payMethods[0].id : null;
    const isMobile = window.matchMedia('(max-width: 600px)');

    function notify(msg, type = 'info'){
        let t=document.getElementById('toast');
        if(!t){
            t=document.createElement('div');
            t.id='toast';
            document.body.appendChild(t);
        }
        t.textContent=msg;
        t.className = 'show ' + type;

        // Click to dismiss
        t.onclick = () => t.classList.remove('show');

        // Auto-hide for success, keep errors visible
        if(type === 'success') {
            setTimeout(() => t.classList.remove('show'), 2500);
        } else if(type === 'error') {
            // Errors stay until clicked
        } else {
            setTimeout(() => t.classList.remove('show'), 1800);
        }
    }

    function getIsCash(pm){ return (pm.protected===true) || (pm.name && pm.name.toLowerCase()==='bar'); }
    function activeIsCash(){ const pm=payMethods.find(p=>p.id===activePM); return pm ? getIsCash(pm) : false; }

    // Items
    const expanded = new Map();
    function addItemQty(id, delta){
        cart[id]=Math.max(0,(cart[id]||0)+delta);
        updateSum();
        updateItemQtyBadges(id);
    }
    function updateItemQtyBadges(id){
        const q=cart[id]||0;
        const b=document.querySelector(`[data-badge="${id}"]`);
        if(b){
            b.style.display = q>0 ? 'inline-flex' : 'none';
            b.textContent=String(q);
        }
        const v=document.querySelector(`[data-qty="${id}"]`);
        if(v){ v.textContent=q; }
    }
    function renderItems(){
        const el=document.getElementById('items');
        if(!el) return;
        el.innerHTML='';
        (items||[]).forEach(it=>{
            const card=document.createElement('div');
            card.className='card item';
            card.dataset.id=it.id;
            card.innerHTML=
                `<div class='row'><h3>${it.name}</h3><div class='price'>${(+it.price).toFixed(2)} ${CURRENCY}</div></div>
             <div class='qty'><button onclick="addItemQty(${it.id},-1)">‚àí</button><div class='val' data-qty='${it.id}'>${cart[it.id]||0}</div><button onclick="addItemQty(${it.id},1)">+</button></div>
             <span class='badge' data-badge='${it.id}'>${cart[it.id]||0}</span>
             <button class='add-quick' onclick="addItemQty(${it.id},1)">+1</button>`;
            if(isMobile.matches){
                card.classList.add('compact');
                card.addEventListener('click', (ev)=>{
                    const insideControls=ev.target.closest('.qty')||ev.target.classList.contains('add-quick')||ev.target.hasAttribute('data-badge');
                    if(insideControls) return;
                    const id=it.id;
                    const isExp=expanded.get(id)===true;
                    expanded.set(id,!isExp);
                    card.classList.toggle('expanded', !isExp);
                    card.classList.toggle('compact', isExp);
                });
                let sx=null;
                card.addEventListener('touchstart',e=>{ sx=e.changedTouches[0].screenX;});
                card.addEventListener('touchend',e=>{
                    if(sx==null) return;
                    const dx=e.changedTouches[0].screenX - sx;
                    if(Math.abs(dx)>40){ addItemQty(it.id, dx>0? +1 : -1); }
                    sx=null;
                });
            }
            el.appendChild(card);
            updateItemQtyBadges(it.id);
        });
    }
    document.addEventListener('click',(e)=>{
        const b=e.target && e.target.closest ? e.target.closest('[data-badge]') : null;
        if(!b) return;
        const id=parseInt(b.getAttribute('data-badge'));
        cart[id]=0;
        updateSum();
        updateItemQtyBadges(id);
        e.stopPropagation();
    });

    // Payment methods
    function renderPM(){
        const el=document.getElementById('pm');
        if(!el) return;
        el.innerHTML='';
        (payMethods||[]).forEach(pm=>{
            const b=document.createElement('button');
            const isActive = pm.id === activePM;
            b.textContent = isActive ? `‚úì ${pm.name}` : pm.name;
            if(isActive) b.classList.add('active');
            b.onclick=()=>{
                activePM=pm.id;
                renderPM();
            };
            el.appendChild(b);
        });
    }

    // Sum
    function cartTotal(){
        let s=0;
        for(const it of (items||[])){
            if(cart[it.id]) s+=cart[it.id]*it.price;
        }
        return s;
    }
    function updateSum(){
        const sumEl=document.getElementById('sum');
        const s=cartTotal();
        if(sumEl) sumEl.textContent=s.toFixed(2);
    }

    // Controls
    const clearBtn=document.getElementById('clear');
    if(clearBtn) clearBtn.onclick=()=>{
        for(const k in cart) delete cart[k];
        activePM = payMethods.length ? payMethods[0].id : null;
        renderItems();
        renderPM();
        updateSum();
        notify('Warenkorb geleert');
    };

    const payBtn=document.getElementById('pay');
    if(payBtn) payBtn.onclick=async()=>{
        const lines=Object.entries(cart).filter(([id,q])=>q>0).map(([id,q])=>({item_id:parseInt(id),qty:q}));
        if(!lines.length){
            notify('Bitte Artikel w√§hlen.', 'warning');
            return;
        }
        if(!activePM){
            notify('Bitte Zahlart w√§hlen.', 'warning');
            return;
        }

        const pm=payMethods.find(p=>p.id===activePM);

        // Disable button and show spinner
        payBtn.disabled = true;
        const originalText = payBtn.innerHTML;
        payBtn.innerHTML = '<span class="spinner"></span>Wird gespeichert...';

        try {
            const res=await fetch('/sale',{
                method:'POST',
                headers:{'Content-Type':'application/json'},
                body:JSON.stringify({lines,payment_method_id:activePM})
            });
            const data=await res.json();

            if(data.ok){
                notify(`‚úì Verkauf gespeichert ‚Äì ${pm ? pm.name : 'OK'}`, 'success');
                for(const k in cart) delete cart[k];
                activePM = payMethods.length ? payMethods[0].id : null;
                renderItems();
                renderPM();
                updateSum();
            } else {
                notify('Fehler: '+(data.msg||'Unbekannt'), 'error');
            }
        } catch(error) {
            notify('Verbindungsfehler ‚Äì Bitte nochmal versuchen', 'error');
        } finally {
            // Re-enable button
            payBtn.disabled = false;
            payBtn.innerHTML = originalText;
        }
    };

    // init
    renderItems();
    renderPM();
    updateSum();

    // ========== TIMER SYSTEM ==========
    let savedTimers = [];  // Aus DB geladen
    let activeTimers = []; // Laufende Timer (nur im Browser)
    let timerInterval = null;

    // Audio Context f√ºr Sound (iOS PWA ben√∂tigt User-Interaktion)
    let audioCtx = null;
    function getAudioCtx() {
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        // iOS: AudioContext muss nach User-Interaktion "resumed" werden
        if (audioCtx.state === 'suspended') {
            audioCtx.resume();
        }
        return audioCtx;
    }

    // iOS PWA: AudioContext bei erstem Touch initialisieren
    function initAudioOnTouch() {
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (audioCtx.state === 'suspended') {
            audioCtx.resume();
        }
        // Stiller "Ping" um Audio zu aktivieren
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        gain.gain.value = 0.001; // unh√∂rbar
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.01);
        // Event-Listener entfernen
        document.removeEventListener('touchstart', initAudioOnTouch);
        document.removeEventListener('click', initAudioOnTouch);
    }
    document.addEventListener('touchstart', initAudioOnTouch, { once: true });
    document.addEventListener('click', initAudioOnTouch, { once: true });

    // Sound-Generatoren
    const SOUNDS = {
        beep: function() {
            const ctx = getAudioCtx();
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.connect(gain); gain.connect(ctx.destination);
            osc.frequency.value = 880; osc.type = 'square'; gain.gain.value = 0.3;
            osc.start(); gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.5);
            osc.stop(ctx.currentTime + 0.5);
            setTimeout(() => {
                const osc2 = ctx.createOscillator();
                const gain2 = ctx.createGain();
                osc2.connect(gain2); gain2.connect(ctx.destination);
                osc2.frequency.value = 1100; osc2.type = 'square'; gain2.gain.value = 0.3;
                osc2.start(); gain2.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.5);
                osc2.stop(ctx.currentTime + 0.5);
            }, 200);
        },

        jingle_bells: function() {
            const ctx = getAudioCtx();
            // E E E, E E E, E G C D E (Jingle Bells Melodie)
            const notes = [659, 659, 659, 0, 659, 659, 659, 0, 659, 784, 523, 587, 659];
            const durations = [150, 150, 300, 100, 150, 150, 300, 100, 150, 150, 150, 150, 400];
            let time = ctx.currentTime;
            notes.forEach((freq, i) => {
                if (freq > 0) {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.connect(gain); gain.connect(ctx.destination);
                    osc.frequency.value = freq; osc.type = 'sine';
                    gain.gain.setValueAtTime(0.25, time);
                    gain.gain.exponentialRampToValueAtTime(0.01, time + durations[i]/1000 - 0.02);
                    osc.start(time); osc.stop(time + durations[i]/1000);
                }
                time += durations[i]/1000;
            });
        },

        christmas_bells: function() {
            const ctx = getAudioCtx();
            // Glockenklang mit Obert√∂nen
            for (let i = 0; i < 4; i++) {
                setTimeout(() => {
                    const fundamental = 600 + Math.random() * 200;
                    [1, 2, 2.4, 3].forEach((mult, j) => {
                        const osc = ctx.createOscillator();
                        const gain = ctx.createGain();
                        osc.connect(gain); gain.connect(ctx.destination);
                        osc.frequency.value = fundamental * mult;
                        osc.type = 'sine';
                        gain.gain.setValueAtTime(0.15 / (j + 1), ctx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 1.5);
                        osc.start(); osc.stop(ctx.currentTime + 1.5);
                    });
                }, i * 400);
            }
        },

        ho_ho_ho: function() {
            const ctx = getAudioCtx();
            // Tiefe T√∂ne wie ein Lachen
            [130, 110, 90].forEach((freq, i) => {
                setTimeout(() => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.connect(gain); gain.connect(ctx.destination);
                    osc.frequency.value = freq;
                    osc.type = 'sawtooth';
                    gain.gain.setValueAtTime(0.2, ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.4);
                    osc.start(); osc.stop(ctx.currentTime + 0.4);
                    // Vibrato
                    const lfo = ctx.createOscillator();
                    const lfoGain = ctx.createGain();
                    lfo.connect(lfoGain); lfoGain.connect(osc.frequency);
                    lfo.frequency.value = 6; lfoGain.gain.value = 10;
                    lfo.start(); lfo.stop(ctx.currentTime + 0.4);
                }, i * 350);
            });
        },

        sleigh_ride: function() {
            const ctx = getAudioCtx();
            // Schnelle fr√∂hliche Gl√∂ckchen
            const notes = [784, 880, 784, 659, 784, 880, 784, 988, 880, 784, 659, 587];
            let time = ctx.currentTime;
            notes.forEach((freq, i) => {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain); gain.connect(ctx.destination);
                osc.frequency.value = freq; osc.type = 'triangle';
                gain.gain.setValueAtTime(0.2, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.1);
                osc.start(time); osc.stop(time + 0.12);
                time += 0.1;
            });
        }
    };

    function playAlarm(soundType = 'beep') {
        const fn = SOUNDS[soundType] || SOUNDS.beep;
        fn();
    }

    function previewSound() {
        const soundType = document.getElementById('newTimerSoundType').value;
        playAlarm(soundType);
    }

    function toggleSoundSelect() {
        const enabled = document.getElementById('newTimerSound').checked;
        document.getElementById('soundSelectRow').style.opacity = enabled ? '1' : '0.4';
    }

    // Modal √∂ffnen/schlie√üen
    function openTimerModal() {
        document.getElementById('timerModal').classList.add('show');
        loadSavedTimers();
    }
    function closeTimerModal() {
        document.getElementById('timerModal').classList.remove('show');
    }

    // Dauer-Inputs umschalten (bei Stoppuhr ausblenden)
    function toggleDurationInputs() {
        const type = document.getElementById('newTimerType').value;
        document.getElementById('durationRow').style.display = type === 'stopwatch' ? 'none' : 'block';
    }

    // Preset-Buttons
    function setDuration(min, sec) {
        document.getElementById('newTimerMin').value = min;
        document.getElementById('newTimerSec').value = sec;
    }

    // Gespeicherte Timer laden
    async function loadSavedTimers() {
        try {
            const res = await fetch('/api/timers');
            const data = await res.json();
            if (data.ok) {
                savedTimers = data.timers;
                renderSavedTimers();
            }
        } catch(e) {
            console.error('Timer laden fehlgeschlagen:', e);
        }
    }

    // Gespeicherte Timer anzeigen
    function renderSavedTimers() {
        const section = document.getElementById('savedTimersSection');
        const list = document.getElementById('savedTimersList');
        if (!savedTimers.length) {
            section.style.display = 'none';
            return;
        }
        section.style.display = 'block';
        const soundNames = {beep:'Beep', jingle_bells:'Jingle Bells', christmas_bells:'Glocken', ho_ho_ho:'Ho Ho Ho', sleigh_ride:'Sleigh Ride'};
        list.innerHTML = savedTimers.map(t => {
            const durStr = t.type === 'stopwatch' ? 'Stoppuhr' : formatTime(t.duration_seconds);
            const soundInfo = t.sound_enabled ? (soundNames[t.sound_type] || 'Beep') : 'üîï';
            return `<div class="saved-timer">
                <div class="info">
                    <div class="label">${escHtml(t.label)}</div>
                    <div class="meta">${durStr} ¬∑ ${soundInfo}</div>
                </div>
                <button class="start-btn" onclick="startSavedTimer(${t.id})">‚ñ∂ Start</button>
                <button class="delete-btn" onclick="deleteTimer(${t.id})">üóë</button>
            </div>`;
        }).join('');
    }

    // Timer erstellen und starten
    async function createAndStartTimer() {
        const label = document.getElementById('newTimerLabel').value.trim();
        const type = document.getElementById('newTimerType').value;
        const min = parseInt(document.getElementById('newTimerMin').value) || 0;
        const sec = parseInt(document.getElementById('newTimerSec').value) || 0;
        const soundEnabled = document.getElementById('newTimerSound').checked;
        const soundType = document.getElementById('newTimerSoundType').value;

        if (!label) {
            notify('Bitte Namen eingeben', 'warning');
            return;
        }

        const durationSeconds = type === 'stopwatch' ? 0 : (min * 60 + sec);
        if (type === 'timer' && durationSeconds <= 0) {
            notify('Bitte Dauer eingeben', 'warning');
            return;
        }

        // Auch in DB speichern (falls noch nicht vorhanden mit gleichem Namen)
        const existing = savedTimers.find(t => t.label === label);
        if (!existing) {
            try {
                await fetch('/api/timers', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        label,
                        type,
                        duration_seconds: durationSeconds,
                        sound_enabled: soundEnabled,
                        sound_type: soundType
                    })
                });
            } catch(e) { /* ignore */ }
        }

        startNewTimer(label, type, durationSeconds, soundEnabled, soundType);
        closeTimerModal();
        resetTimerForm();
    }

    // Timer als Preset speichern
    async function saveTimerPreset() {
        const label = document.getElementById('newTimerLabel').value.trim();
        const type = document.getElementById('newTimerType').value;
        const min = parseInt(document.getElementById('newTimerMin').value) || 0;
        const sec = parseInt(document.getElementById('newTimerSec').value) || 0;
        const soundEnabled = document.getElementById('newTimerSound').checked;
        const soundType = document.getElementById('newTimerSoundType').value;

        if (!label) {
            notify('Bitte Namen eingeben', 'warning');
            return;
        }

        const durationSeconds = type === 'stopwatch' ? 0 : (min * 60 + sec);

        try {
            const res = await fetch('/api/timers', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    label,
                    type,
                    duration_seconds: durationSeconds,
                    sound_enabled: soundEnabled,
                    sound_type: soundType
                })
            });
            const data = await res.json();
            if (data.ok) {
                notify('Timer gespeichert', 'success');
                loadSavedTimers();
                resetTimerForm();
            } else {
                notify(data.msg || 'Fehler', 'error');
            }
        } catch(e) {
            notify('Verbindungsfehler', 'error');
        }
    }

    // Gespeicherten Timer starten
    function startSavedTimer(id) {
        const t = savedTimers.find(x => x.id === id);
        if (!t) return;
        startNewTimer(t.label, t.type, t.duration_seconds, t.sound_enabled, t.sound_type || 'beep');
        closeTimerModal();
    }

    // Timer l√∂schen
    async function deleteTimer(id) {
        if (!confirm('Timer wirklich l√∂schen?')) return;
        try {
            const res = await fetch(`/api/timers/${id}`, { method: 'DELETE' });
            const data = await res.json();
            if (data.ok) {
                notify('Timer gel√∂scht', 'success');
                loadSavedTimers();
            }
        } catch(e) {
            notify('Fehler beim L√∂schen', 'error');
        }
    }

    // Neuen aktiven Timer starten
    function startNewTimer(label, type, durationSeconds, soundEnabled, soundType = 'beep') {
        const timer = {
            uid: Date.now() + Math.random(),
            label,
            type,
            durationSeconds,
            soundEnabled,
            soundType,
            currentSeconds: type === 'stopwatch' ? 0 : durationSeconds,
            running: true,
            finished: false,
            startedAt: Date.now()  // F√ºr Persistenz
        };
        activeTimers.push(timer);
        renderActiveTimers();
        startTimerInterval();
        updateTimerBadge();
        saveActiveTimersToStorage();
    }

    // Timer-Interval starten
    function startTimerInterval() {
        if (timerInterval) return;
        timerInterval = setInterval(() => {
            let needsRender = false;
            let needsSave = false;
            activeTimers.forEach(t => {
                if (!t.running || t.finished) return;
                if (t.type === 'stopwatch') {
                    t.currentSeconds++;
                    needsRender = true;
                    needsSave = true;
                } else {
                    t.currentSeconds--;
                    needsRender = true;
                    needsSave = true;
                    if (t.currentSeconds <= 0) {
                        t.currentSeconds = 0;
                        t.finished = true;
                        t.running = false;
                        if (t.soundEnabled) playAlarm(t.soundType || 'beep');
                        notify(`Timer "${t.label}" abgelaufen!`, 'warning');
                    }
                }
            });
            if (needsRender) renderActiveTimers();
            if (needsSave) saveActiveTimersToStorage();
        }, 1000);
    }

    // Timer stoppen/interval beenden wenn keine aktiven
    function checkTimerInterval() {
        if (!activeTimers.length && timerInterval) {
            clearInterval(timerInterval);
            timerInterval = null;
        }
    }

    // Aktive Timer rendern
    function renderActiveTimers() {
        const container = document.getElementById('activeTimers');
        const grid = document.getElementById('activeTimersGrid');

        if (!activeTimers.length) {
            container.classList.remove('has-timers');
            grid.innerHTML = '';
            return;
        }

        container.classList.add('has-timers');

        // Grid-Spalten basierend auf Anzahl
        const count = activeTimers.length;
        grid.className = 'active-timers-grid';
        if (count === 1) grid.classList.add('cols-1');
        else if (count === 2) grid.classList.add('cols-2');
        else grid.classList.add('cols-3');

        grid.innerHTML = activeTimers.map(t => {
            const state = t.finished ? 'finished' : (t.running ? 'running' : 'paused');
            const playIcon = t.running ? '‚è∏' : '‚ñ∂';
            return `<div class="active-timer ${state}">
                <div class="timer-info" onclick="toggleTimer('${t.uid}')">
                    <div class="timer-label">${escHtml(t.label)}</div>
                    <div class="timer-display">${formatTime(t.currentSeconds)}</div>
                </div>
                <div class="timer-controls">
                    <button class="play-pause" onclick="toggleTimer('${t.uid}')">${playIcon}</button>
                    <button class="reset-btn" onclick="resetTimer('${t.uid}')">‚Ü∫</button>
                    <button class="stop-btn" onclick="removeTimer('${t.uid}')">‚úï</button>
                </div>
            </div>`;
        }).join('');
    }

    // Timer pausieren/fortsetzen
    function toggleTimer(uid) {
        const t = activeTimers.find(x => x.uid == uid);
        if (!t) return;
        if (t.finished) {
            // Reset wenn fertig
            t.currentSeconds = t.type === 'stopwatch' ? 0 : t.durationSeconds;
            t.finished = false;
            t.startedAt = Date.now();
        }
        t.running = !t.running;
        if (t.running) {
            t.resumedAt = Date.now();
        } else {
            t.pausedAt = Date.now();
        }
        renderActiveTimers();
        saveActiveTimersToStorage();
        if (t.running) startTimerInterval();
    }

    // Timer zur√ºcksetzen
    function resetTimer(uid) {
        const t = activeTimers.find(x => x.uid == uid);
        if (!t) return;
        t.currentSeconds = t.type === 'stopwatch' ? 0 : t.durationSeconds;
        t.finished = false;
        t.running = false;
        t.startedAt = Date.now();
        renderActiveTimers();
        saveActiveTimersToStorage();
    }

    // Timer entfernen
    function removeTimer(uid) {
        activeTimers = activeTimers.filter(x => x.uid != uid);
        renderActiveTimers();
        updateTimerBadge();
        checkTimerInterval();
        saveActiveTimersToStorage();
    }

    // Badge aktualisieren
    function updateTimerBadge() {
        const badge = document.getElementById('timerBadge');
        if (activeTimers.length > 0) {
            badge.style.display = 'inline';
            badge.textContent = activeTimers.length;
        } else {
            badge.style.display = 'none';
        }
    }

    // Formular zur√ºcksetzen
    function resetTimerForm() {
        document.getElementById('newTimerLabel').value = '';
        document.getElementById('newTimerType').value = 'timer';
        document.getElementById('newTimerMin').value = '5';
        document.getElementById('newTimerSec').value = '0';
        document.getElementById('newTimerSound').checked = true;
        document.getElementById('newTimerSoundType').value = 'beep';
        toggleDurationInputs();
        toggleSoundSelect();
    }

    // Hilfsfunktionen
    function formatTime(secs) {
        const m = Math.floor(secs / 60);
        const s = secs % 60;
        return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
    }
    function escHtml(str) {
        return String(str).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
    }

    // LocalStorage Persistenz
    const TIMER_STORAGE_KEY = 'pos_active_timers';

    function saveActiveTimersToStorage() {
        try {
            const data = activeTimers.map(t => ({
                uid: t.uid,
                label: t.label,
                type: t.type,
                durationSeconds: t.durationSeconds,
                soundEnabled: t.soundEnabled,
                soundType: t.soundType,
                currentSeconds: t.currentSeconds,
                running: t.running,
                finished: t.finished,
                savedAt: Date.now()
            }));
            localStorage.setItem(TIMER_STORAGE_KEY, JSON.stringify(data));
        } catch(e) { /* ignore */ }
    }

    function loadActiveTimersFromStorage() {
        try {
            const raw = localStorage.getItem(TIMER_STORAGE_KEY);
            if (!raw) return;
            const data = JSON.parse(raw);
            if (!Array.isArray(data) || !data.length) return;

            const now = Date.now();
            data.forEach(t => {
                // Berechne verstrichene Zeit seit Speicherung
                const elapsed = Math.floor((now - t.savedAt) / 1000);

                if (t.running && !t.finished) {
                    if (t.type === 'stopwatch') {
                        t.currentSeconds += elapsed;
                    } else {
                        t.currentSeconds -= elapsed;
                        if (t.currentSeconds <= 0) {
                            t.currentSeconds = 0;
                            t.finished = true;
                            t.running = false;
                        }
                    }
                }

                activeTimers.push({
                    uid: t.uid,
                    label: t.label,
                    type: t.type,
                    durationSeconds: t.durationSeconds,
                    soundEnabled: t.soundEnabled,
                    soundType: t.soundType || 'beep',
                    currentSeconds: t.currentSeconds,
                    running: t.running,
                    finished: t.finished
                });
            });

            renderActiveTimers();
            updateTimerBadge();
            if (activeTimers.some(t => t.running)) {
                startTimerInterval();
            }
        } catch(e) {
            console.error('Timer aus Storage laden fehlgeschlagen:', e);
        }
    }

    // Initialisierung
    loadSavedTimers();
    loadActiveTimersFromStorage();
</script>
</body>
</html>